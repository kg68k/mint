// create builtin function name and label table for mint
// Copyright (C) 2024 TcbnErik

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FUNC_MAX 256

#define FUNC_NAME_BITS 12
#define FUNC_ADDR_BITS (32 - FUNC_NAME_BITS)
#define FUNC_ADDR_BASE "mint_start"

typedef struct {
  const char* name;
  const char* label;
} Func;

static int funcsLen;
static Func funcs[FUNC_MAX];

static void Error(const char* fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);

  exit(EXIT_FAILURE);
}

static char* Strdup(const char* s) {
  char* t = strdup(s);
  if (!t) Error("メモリが不足しています。\n");
  return t;
}

static char* Fgets(char* buf, size_t size, FILE* fp) {
  char* result = fgets(buf, size, fp);
  if (result) {
    char* p = strchr(buf, '\n');
    if (p) *p = '\0';
  }
  return result;
}

static const char FullWidthAnd[] = {0x81, 0x95};  // Shift_JIS ＆

/// @brief ".global ＆func_name\n" 形式の行からラベルを抽出する
static const char* extractLabel(char* s) {
  char* end;
  const char header[] = ".globl ";

  if (strncmp(s, header, strlen(header)) != 0) return NULL;
  while (*s && *s != ' ') s += 1;
  while (*s && *s == ' ') s += 1;
  if (memcmp(s, FullWidthAnd, sizeof(FullWidthAnd)) != 0) return NULL;

  for (end = s + sizeof(FullWidthAnd); *end && *end > 0x20;) end += 1;
  *end = '\0';

  return Strdup(s);
}

/// @brief "＆func_name" 形式のラベルを "func-name" 形式の関数名に変換する
static const char* labelToKey(const char* s) {
  char* buf;
  char* p;

  if (!s) return NULL;
  buf = Strdup(s + sizeof(FullWidthAnd));
  for (p = buf; *p; p += 1) {
    if (*p == '_') *p = '-';
  }

  return buf;
}

static int compareFuncName(const void* a, const void* b) {
  return strcmp(((const Func*)a)->name, ((const Func*)b)->name);
}

static void ReadLines(const char* filename, FILE* fp) {
  char buf[256];
  int line = 1;

  while (Fgets(buf, sizeof(buf), fp)) {
    const char* label = extractLabel(buf);
    const char* name = labelToKey(label);

    if (!label || !name) continue;

    if (funcsLen == FUNC_MAX)
      Error("%s: %d: 内部関数が多すぎます: \n", filename, line, buf);

    funcs[funcsLen] = (Func){name, label};
    funcsLen += 1;
  }

  if (funcsLen == 0) Error("%s: 内部関数がありません。\n", filename);

  qsort(funcs, funcsLen, sizeof(funcs[0]), compareFuncName);
}

static void outputFuncLabel(void) {
  const int bits = FUNC_ADDR_BITS;
  int i;

  puts("\nX: .reg FUNC_ADDR_BASE\n.quad\nFuncAddrTable:");
  for (i = 0; i < funcsLen; i += 1) {
    printf("  .dc.l (s%03d-S)<<%d+%s-X\n", i, bits, funcs[i].label);
  }
  puts("FuncAddrTableEnd:");
}

static void outputFuncName(void) {
  int i;

  puts("\nFuncNameList:\nS:");
  for (i = 0; i < funcsLen; i += 1) {
    printf("s%03d: .dc.b '%s',0\n", i, funcs[i].name);
  }
}

static void Output(void) {
  puts("# mint builtin function table\n# generated by mkfunctbl");
  printf(
      "\n.xref %s\nFUNC_ADDR_BASE: .reg %s\n"
      "FUNC_NAME_BITS: .equ %d\nFUNC_ADDR_BITS: .equ %d\n",
      FUNC_ADDR_BASE, FUNC_ADDR_BASE, FUNC_NAME_BITS, FUNC_ADDR_BITS);
  puts("\n.data");
  outputFuncLabel();
  outputFuncName();
  puts("\n.text");
}

int main(void) {
  ReadLines("<stdin>", stdin);
  Output();

  return EXIT_SUCCESS;
}
